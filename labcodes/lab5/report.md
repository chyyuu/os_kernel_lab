# Lab 5

## 知识点

这些是与本实验有关的原理课的知识点：

* 进程状态模型
* 用户进程

此外，本实验还涉及如下知识点：

* ELF文件格式
* 写时复制

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

* 挂起的进程

## 练习0

首先，需要对之前的代码进行微小的修改：

1. `alloc_proc`加入对新增字段的初始化，由于我使用`memset`初始化，不需要修改
2. `do_fork`时设置对父进程的指针
3. `do_fork`时将进程插入进程链表、增加进程计数器的操作，替换为`set_links`函数，该函数不仅有上面两个操作，还设置了进程间的关系指针
4. `ticks % TICK_NUM == 0`时，将打印提示信息替换为将当前进程的`need_resched`置1，表明当前进程时间片已耗尽，需要运行调度器
5. `idt_init`中我已在Lab 1已经设置了系统调用的门，这个实验不需要修改了

## 练习1

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。主要就是修改`load_icode`，补上对`trapframe`结构体的初始化。初始化的核心是`eip`以及`esp`。`eip`需要设为ELF映像中定义的入口点，`esp`则设为用户栈顶，由于开启了分页，它只需要设置为一个常数，为用户栈顶的虚拟地址`USTACKTOP`。

当创建一个用户态进程并加载了应用程序，并且内核调度器选择此进程开始执行，过程为：

1. `proc_run`被调用，`current`被置为此进程控制块的指针，标志着此进程成为运行状态
2. 加载该进程的内核栈和页表
3. `switch_to`被调用，由于此进程的`context`的`eip`被置为`forkret`，`switch_to`最终跳转到`forkret`
4. `forkret`进而跳转到`__trapret`，`__trapret`开始的代码是进入用户态的关键
5. `__trapret`首先根据当前进程的`trapframe`结构体“恢复”（加载）内核新构造的中断上下文，最后使用`iret`指令同时完成跳转到用户进程入口点、切换到用户栈以及切换到用户态的操作

具体而言，处理器在执行`iret`指令时，当前栈的布局是这样的：

```
|  high address  |
------------------
|   SS (ring3)   |
------------------
|       ESP      |
------------------
|     EFLAGS     |
------------------
|   CS (ring3)   |
------------------
|       EIP      |  <---- ESP, CS=ring0
------------------
|  low  address  |
```

当处理器发现栈中的`CS`为ring3，它在弹出`EFLAGS`之后还会弹出`SS`和`ESP`，并将它们赋给相应寄存器。

至此，处理器的`iret`指令就同时完成了跳转到用户进程入口点、切换到用户栈以及切换到用户态的操作。

我的实现和参考答案十分一致。

## 练习2

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。需要补充的地方是`copy_range`函数中拷贝内存和将页面映射信息填入页表的实现。

值得说明的是，我最初实现时手动填写了页表项，而没有调用`page_insert`，可能会造成引用计数维护错误，后来自己发现并修复了。

我的实现和参考答案十分一致。

写时复制的设计与实现请见下面的小节。

## 练习3

**fork**

`fork`创建了一个新的进程控制块，此时进程为UNINIT，然后将当前进程几乎所有信息复制到了新的进程。没有复制的信息包括内核栈和用于存放返回值的`eax`寄存器，它们都是新的。

在`wakeup_proc`被调用之后，进程状态变为RUNNABLE的就绪态。

**exec**

`exec`先将当前进程的内存布局（  `mm`结构体）清除干净，然后调用`load_icode`填写目标ELF映像中说明的内存布局。注意，进程的状态不发生变化。

**wait**

这个系统调用涉及两个进程，当前进程及其子进程。`wait`首先检查当前进程是否有子进程，若无则直接返回错误。接着，检查是否有ZOMBIE状态的子进程，若有则直接释放子进程残存的资源，然后立即返回子进程的返回状态码，此时子进程已不存在。

若没有ZOMBIE状态的子进程，此进程变为SLEEPING状态，等待这样的子进程出现，再进行上面的操作。

**kill**

这里的`kill`实现不是发信号，而是将指定进程的标记为设为EXITING，在下一次中断来临时，让进程调用`exit`来自己杀死自己，从而变成ZOMBIE状态。注意，`kill`并不直接改变进程的状态。

**exit**

这个系统调用涉及两个进程，当前进程及其父进程。`exit`会清除当前进程几乎所有资源，除了进程控制块以及内核栈，接着将其所有子进程的父进程置为init进程，然后将当前进程的状态变为ZOMBIE。若该进程有父进程，并且父进程正在等待子进程退出，则将父进程的状态从SLEEPING变为RUNNABLE态。

总结成状态转移图如图所示：

```
  ?               RUNNING
  |                A    |
  |                |    |
 (1)              (3)  (4)
  |                |    |
  V                |    V
UNINIT -- (2) --> RUNNABLE -- (7) --> ZOMBIE -- (8) --> ?
                   A    |               A
                   |    |               |
                  (6)  (5)             (7)
                   |    |               |
                   |    V               |
                  SLEEPING -------------+
```

(1) `alloc_proc`

(2) `wakeup_proc`

(3) `proc_run`被调用时，作为`proc_run`的参数

(4) `proc_run`被调用时，作为`proc_run`的调用者

(5) 调用了`wait`（或`sleep`，上面没有涉及）

(6) 子进程调用了`exit`（或定时器超时，上面没有涉及）

(7) 调用了`exit`

(8) 父进程调用了`wait`

## 扩展练习 - 写时复制的设计与实现

我的写时复制实现主要修改两个函数。具体实现请见`lab5-challenge`分支。

对于`copy_range`，我将函数`share`参数的语义定义为是否用写时复制的方式实现内存的“复制”。为此，该函数需要在申请页面之前进行判断，若是开启写时复制，则直接使用已存在的页面；在把原来的内容复制到新页面的时候也需要进行判断，若是开启写时复制，就不需要复制了。然后，同样用`page_insert`完成页表映射和引用计数增加1的操作，但对于写时复制，还需要设置可写位（W位）为0。此外，对于写时复制，还需要将原来页面页表项的可写位（W位）清零并刷新TLB，因为这个页面已经变成共享的页面了。对于`dup_mmap`，需要将传入给`copy_range`的`share`参数变为1（代表开启写时复制）。

此时，对于共享页面的写操作会导致页错误异常，为此需要进一步修改页错误异常处理程序`do_pgfault`来最终实现写时复制。

`do_pgfault`已有的代码已经对页面访问权限的情况做了很详细的检查，若能执行到并且通过`(*ptep & PTE_P)`的判断，说明该进程有权限对该页面进行操作，而该页面又确实真正存在于物理内存中，但此时还是发生了页错误异常，表明页表中存储的权限和该进程实际拥有的权限不一致。这个不一致性告诉内核，这是一个需要写时复制的页面，它可能正在和其它进程共享（如果页面引用计数大于1）。此时，内核才需要真正分配一个新的页面，复制数据，然后修改这个进程的页表项，重新映射对应的虚拟地址，并维护页面的引用计数。这次映射的时候，可写位（W位）就可以设置为1了。

考虑出错页面的引用计数恰好等于1的特殊情况。这个情况说明该页面曾经被共享过，但其他进程又对这个页面进行了写操作，分裂出去了。进一步，这说明该页面已经没有和其他进程共享，只需要修改页表项将此虚拟地址对应的可写位（W位）置1并刷新TLB即可。

至此，写时复制的实现就比较完整了。

另外，我的实现没有考虑挂起的情况。