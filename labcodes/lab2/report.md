# Lab 2

## 知识点

这些是与本实验有关的原理课的知识点：

* 首次匹配
* x86分页机制
* 二级页表

此外，本实验还涉及如下知识点：

* 内核实现的通用链表

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

* 最佳匹配
* 最差匹配
* 碎片整理技术
* 反置页表

## 练习1

实验代码已经提供了某种连续内存分配算法，为实现首次匹配，需要修改代码，维护`free_list`有如下性质：

1. 链表中的页面块均为空闲
2. 每个空闲页面块首个页面挂在链表中，对应的`Page`结构体有属性，为页面块的页面数；该页面块其余页面不直接挂在链表中，也没有属性，属性值的位置清零
3. 链表中页面块按照首地址增序排列

### 对于`default_alloc_pages`函数的修改

需要修改`default_alloc_pages`函数来维护上面的性质，但改动不大。

主要修改就是将新分裂出来的页面块（若有）设置好属性并插入正确的位置，而不是直接插入到`free_list`最后。

正确的位置实际上就是原页面块原来位置的后一项。实现上，可以先将新分裂出的页面块插入，再将分配出去的页面块移出。

### 对于`default_free_pages`函数的修改

还需要修改`default_free_pages`函数来维护上述性质，但改动不大。

在重新设置页面属性、合并相邻页面后，需要将该页面插入到链表正确的位置中，也就是将原来的`list_add(&free_list, &(base->page_link));`替换为一个循环，根据页面首地址找到正确的位置然后插入。

### 改进

这个分配算法还可能继续优化，优化可能有如下几点：

1. 释放时的合并操作，在查找与该空闲块相邻的下一个块时不需要循环遍历查找，只需要根据当前块的页面数计算出来即可，接着判断下一个页面块是否空闲，然后尝试合并
2. 释放时的合并操作，若是在所有页面块最后一个页面处也记录这个页面块的页面数，则在查找与该新释放出的空闲块相邻的上一个块时也不需要循环遍历查找，只需要根据上一块的页面数计算出来即可，接着判断是否空闲，然后尝试合并
3. 源于这样一个简单的想法：上次成功的地方之后还可能有空闲块。因此，查找空闲块时从上一次成功分配的块开始查找，直到链表末尾，然后卷回链表起始继续查找，直到重新回到上一次成功的位置，用循环链表实现非常简单。这其实是下一次适配。

与参考答案对比，我认为我的实现对原来实验代码的修改较小，思路清晰，实现简洁。

## 练习2

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。

这个练习主要是页目录项的填写，页目录项的字段见下。

```
 31               12 11 9 8 7 6 5 4 3 2 1 0
+-------------------+----+-+-+-+-+-+-+-+-+-+
|   页表基址高20位   |忽略|G|S|0|A|C|T|U|W|P|
+-------------------+----+-+-+-+-+-+-+-+-+-+
```

说明：

* 页表基址：页表的**物理地址**，需要4KB对齐，所以只需填写高20位
* 忽略：内核可以记录自己需要的信息
* G：对于页目录，这一项不用
* S：页大小，1为4MB，0为4KB；ucore置为0
* A：在上次清零之后，该页是否被访问（读或者写）过，可用于页替换算法的实现
* C：置1则不缓存，否则缓存
* T：置1则缓存写穿，否则写回
* U：置0则页表中任何页面只能内核态访问，否则用户态可能可以访问，还取决于页表项的设置
* W：页面是否可写，但若CR0的WP位置为0，内核总可以写
* P：页面是否存在于内存中

页表项的字段和页目录项十分类似：

```
 31               12 11 9 8 7 6 5 4 3 2 1 0
+-------------------+----+-+-+-+-+-+-+-+-+-+
|   页基地址高20位   |忽略|G|0|D|A|C|T|U|W|P|
+-------------------+----+-+-+-+-+-+-+-+-+-+
```

说明：

- 页基地址：页面的**物理地址**，需要4KB对齐，所以只需填写高20位
- 忽略：内核可以记录自己需要的信息
- G：这一页表项是否是全局项，若被置位，在CR3改变时，相应TLB不被清除，对于内核的页面映射，可以设置此位来优化内核访问内存的性能
- D：在上次清零之后，该页是否被写过，可用于页替换算法的实现
- U：置0则该页面只能内核态访问，否则用户态可以访问
- P：页面是否存在于内存中
- 其余位和页目录项含义相同

另外，当P位清零时，其余位都可供内核自由使用。这可以用来存放交换分区的一些信息，可用于页替换算法的实现。

如果ucore执行过程中访问内存，出现了页错误异常，处理器会将异常的线性地址保存在CR2寄存器中，然后查询IDT找到中断服务程序入口点。由于当前已在内核态，不涉及特权级的变化，处理器还会向当前栈中压入cs、eip和错误码。错误码记录了异常的一些标志，比如是读还是写操作触发了异常，是非法访问还是缺页触发了异常，这对于页替换算法和写时复制的实现都有用。最后，跳转至中断服务程序。这些事情中间还会做权限检查，不通过还会触发保护错误。这些事情执行的顺序可能与处理器实现有关。

与参考答案对比，我没有判断`alloc_page`失败的情况，应修复。

## 练习3

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。主要实现的就是页目录项的清除和页面引用计数的维护。另外，还需要清除TLB。

无论是页目录中的页目录项还是页表中的页表项，它们的高20位都是物理页号，以此作为索引，可以在`Page`结构体数组中找到对应物理页的元数据，正如`pte2page`宏实现的那样。

若要实现虚拟地址与物理地址相等，需要将`KERNBASE`改为`0x00000000`，同时需要做一些其他辅助性的修改:

1. 链接脚本`kernel.ld`需要修改链接的虚拟地址为`0x00100000`
2. 清除页目录项`boot_pgdir[0] = 0;`赋值前需要检查`KERNBASE`，若为0则不清除
3. 断言`assert(boot_pgdir[0] == 0);`也需要检查`KERNBASE`，若为0则不执行断言
4. 其他测试代码使用的地址区域应避开`0x00000000 ~ 0x38000000`
5. 测试脚本`grade.sh`中的测例也需要相应修改

具体修改见`lab2-zero`分支。

与参考答案对比，我在减少和判断页面引用计数时将两个操作分开进行了，在某些情况下可能会有重复释放页面的问题，应修复。