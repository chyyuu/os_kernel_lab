# Lab 1

## 知识点

这些是与本实验有关的原理课的知识点：

* 系统启动
* x86的中断和异常机制
* 用中断实现系统调用
* 中断描述符表

此外，本实验还涉及如下知识点：

* 硬盘驱动程序
* ELF文件格式

遗憾的是，如下知识点在原理课中很重要，但本次实验没有很好的对应：

无

## 练习1

使用`make "V="`命令得到如下生成ucore.img磁盘镜像的过程，具体的命令及它们的输出见`make_cmds.txt`。

### 1. 编译生成内核代码

命令为`gcc -I... -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -c kern/***.c -o obj/kern/***.o`。

该条命令：

1. `-I...`设定了引用文件查找目录
2. `-fno-builtin -nostdinc`关闭了内建的库
3. `-Wall`开启所有警告
4. `-ggdb -gstabs`添加调试信息
5. `-m32`生成32位代码
6. `-fno-stack-protector`不生成栈保护代码
7. 最后，把`kern`下的.c代码生成到`obj/kern`的.o文件

### 2. 链接生成内核映像 

命令为`ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel obj/***.o`。

该条命令：

1. `-m elf_i386`生成32位ELF映像
2. `-nostdlib`关闭了内建的库
3. `-T tools/kernel.ld`使用链接器脚本`tools/kernel.ld`，这个脚本描述了代码和数据在内存中的布局，以及设定了内核入口地址
4. `-o bin/kernel obj/***.o`把`obj`下的.o文件链接生成`bin/kernel`文件

### 3. 编译生成bootloader代码

命令为`gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -c boot/bootasm.S -o obj/boot/bootasm.o`。

命令参数的含义几乎与1.完全类似。

特别地：

* `-Os`表示对生成代码的大小进行优化，开启此选项的目的是满足启动扇区510字节代码的限制，若优化后仍超过大小，就需要手动编写汇编来优化了

### 4. 链接生成bootloader映像

命令为`ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/***.o -o obj/bootblock.o`。

该条命令：

1. `-m elf_i386`生成32位ELF映像
2. `-nostdlib`关闭了内建的库
3. `-N`设置代码段和数据段都可读可写，关闭动态链接
4. `-e start`指定入口点符号为`start`
5. `-Ttext 0x7C00`设置代码段起始地址为`0x7c00`
6. `obj/boot/***.o -o obj/bootblock.o`把`obj/boot/`下的.o文件链接生成`obj/bootblock.o`文件

### 5. 生成bootloader二进制代码

命令为`objcopy -S -O binary obj/bootblock.o obj/bootblock.out`。

该条命令：

1. `-S`不拷贝重定位信息和调试信息
2. `-O binary`拷贝二进制代码
3. `obj/bootblock.o obj/bootblock.out`将ELF格式的`obj/bootblock.o`文件中的代码段拷贝到`obj/bootblock.out`

### 6. 生成启动扇区

为生成启动扇区，先编译生成`tools/sign.c`工具。该工具检查`obj/bootblock.out`文件的大小是否超过510字节，然后利用这个文件生成启动扇区`bin/bootblock`。启动扇区的特点见下。

### 7. 初始化磁盘镜像文件

命令为`dd if=/dev/zero of=bin/ucore.img count=10000`。

该条命令：

1. `if=/dev/zero`从全零的一个设备文件读取
2. `of=bin/ucore.img`写入到`bin/ucore.img`
3. `count=10000`共10000个扇区（共5120000字节）

### 8. 将启动扇区写入镜像文件

命令为`dd if=bin/bootblock of=bin/ucore.img conv=notrunc`。

该条命令：

1. `if=bin/bootblock`从6.生成的启动扇区文件读取
2. `of=bin/ucore.img`写入到`bin/ucore.img`
3. `conv=notrunc`不将`bin/ucore.img`文件清空

### 9. 将内核映像写入镜像文件

命令为`dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc`。

该条命令：

1. `if=bin/kernel`从2.生成的内核映像文件读取
2. `of=bin/ucore.img`写入到`bin/ucore.img`
3. `seek=1`写入时，从第1扇区开始写入
4. `conv=notrunc`不将`bin/ucore.img`文件清空

### 启动扇区的特点

能够被BIOS识别的启动扇区有如下特点：

1. 符合扇区基本要求，大小512字节
2. 最后两个字节，即第510和511个字节，分别为`0x55 0xAA`；若表示为一个16位的字，则为`0xAA55`（小端序）

若是有分区信息，中间还将有分区表。

## 练习2

首先，将`gdbinit`脚本中如下两行**去掉**，使得运行`make debug`时不自动开始运行。

```
break kern_init
continue
```

然后运行`make debug`开始实验。

此时，QEMU停在`0xfffffff0`，使用`i r`命令得到，cs=`0xf000`，eip=`0xfff0`。GDB对于段机制的处理不是很好，所以需要手动指定物理地址来查看相应代码。

执行`x/i 0xfffffff0`可以得到开机后执行的第一条指令：`ljmp $0x3630, $0xf000e05b`。指令很奇怪，这是由于没有设置指令集为16位，GDB默认是32位，导致反汇编错误，使用`set arch i8086`设置之后重新`x/i 0xfffffff0`，得到正确结果：`ljmp $0xf000, $0xe05b`。

执行几次`si`，查看指令的执行情况，发现果真跳转到`0xfe05b`开始执行了。

执行`b *0x7c00`在`0x7c00`处设下断点，执行`c`使得QEMU继续运行，之后发现在`0x7c00`暂停了，断点有效。

执行`x/10i 0x7c00`查看反汇编，发现与`bootasm.S`一致，但与`bootblock.asm`不太一致。这是由于反汇编生成`bootblock.asm`时，使用的是32位指令集。

现在开始调试设置A20的代码。

执行`b *0x7c0a`在`0x7c0a`设下断点，然后使用`si`单步执行，期间用`layout`切换格局，可以同时查看汇编代码以及寄存器的值。

## 练习3

系统加电时，处理器处于实模式状态，为了让它进入保护模式使用完整的32位地址线以及实现更多的保护功能，需要进行一些准备，然后将CR0中PE位置位，最后处理器开始执行保护模式下32位代码。

详细操作描述如下：

### 1. 开启第20位地址线（A20）

由于历史原因，进入保护模式之前，需要开启第20位地址线（下面简称A20）来获得使用完整4G内存的能力。

`bootasm.S`中开始A20的方法是：

1. 等待直到8042不忙
2. 向8042控制端口写入写P2端口命令（`0xd1`）
3. 等待直到8042不忙
4. 向8042数据端口写入`0xdf`来打开A20

值得注意，随着时代的发展，开启A20的方法千变万化，这只是其中的一种。

### 2. 配置全局描述符表（GDT）

由于本实验弱化对于分段机制的使用，GDT及其基址和界限的描述可以硬编码在代码中。GDT中有三个描述符：空描述符、代码段描述符以及数据段描述符。然后，用`lgdt`载入GDT的基址和界限即可。注意，GDT需要4字节对齐。

### 3. 开启保护模式

将CR0的PE位（第0位）置1即可开启保护模式。注意，置1后，处理器并未立即开始执行32位代码。

### 4. 开始执行32位代码

使用远跳转指令`ljmp`，将代码段寄存器`cs`设置为新的值（代码段选择子），从而真正开始32位保护模式。

由于2.配置GDT时将代码段设置为恒等映射，同时未开启分页机制，逻辑地址和物理地址直接相等，跳转目标就是下一条指令的地址。

注意跳转后还应该将各个数据段寄存器也设置为新的值（数据段选择子）。

## 练习4

为了能够将内核映像加载到物理内存，首先需要读取扇区。

`bootmain.c`通过`inb`、`insl`、`outb`指令来和磁盘控制器进行通讯，使用最朴素的方法读取扇区（没有DMA或中断）。读取一个扇区分为如下几步：

1. 等待磁盘控制器就绪
2. 用`outb`指令设置要读取的数量、读取的LBA（这里使用LBA编址方式）
3. 用`outb`指令向控制端口写入读取扇区命令
4. 用`repne insl`指令读取相应数量的双字（128个双字即为512字节），实际上是一个循环

有了读扇区的基础，可以开始读取并解析ELF格式的内核映像。

ELF格式的内核映像有ELF头结构，里面标识了程序节的个数，每个程序节说明了该节在映像中的偏移、长度以及应加载到内存的位置，据此读取每一个程序节并存入正确的地址即可。

最后，ELF头结构里面有内核的入口点地址，是一个整数，可以通过将此整数转换为函数指针然后调用来跳转到内核。

## 练习5

这个练习提供的注释已经写得非常详细，根据它写出C代码即可。本练习的关键点在于C语言调用约定和栈。

某函数被调用后，初始化栈帧完毕之后的栈局势如下图：

```
|高地址方向|
-----------
| 第四参数 | ebp + 5 dword
-----------
| 第三参数 | ebp + 4 dword
-----------
| 第二参数 | ebp + 3 dword
-----------
| 第一参数 | ebp + 2 dword
-----------
| 返回地址 | ebp + 1 dword
-----------
|  旧ebp  | <==== ebp, esp + 0
-----------
|低地址方向|
```

此外，值得讨论的是，给`print_debuginfo`传参数的时候需要传入eip-1的值，这是因为eip指向了下一条指令，而程序希望处理当前指令。还需注意的是，`read_ebp`定义为必须内联，`read_eip`定义为不得内联，这都是为了能够获得ebp和eip的真实的值。

测试输出有意义的最后一行为：

```
ebp:0x00007bf8 eip:0x00007d6e args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
```

这是第一个被调用的函数的信息，查看`bootasm.S`的第68~71行后发现实际上是调用了`bootmain`。

`0x00007bf8`是bootmain的栈帧基址；

`0x00007d6e`是这条语句后一条语句的起始地址，也是`bad`标签的地址：

```c
((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
```

`args`本应为`bootmain`的前4个参数，而`bootmain`根本没有参数，所以这4个32位整数就是调用`bootmain`**之前**，栈顶的4个32位整数。注意到调用`bootmain`之前，esp被赋值为`0x7c00`，于是`0xc031fcfa`、`0xc08ed88e`、`0x64e4d08e`、`0xfa7502a8`实际上为位于`0x7c00~0x7c0f`的代码：

````
0xfa 0xfc 0x31 0xc0
0x8e 0xd8 0x8e 0xc0
0x8e 0xd0 0xe4 0x64
0xa8 0x02 0x75 0xfa
````

查看`bootblock.asm`验证了这一点。

经过与参考答案对比，我在ebp为0时没有停止循环，应修复。

## 练习6

这个练习提供的注释已经写得非常详细，比实际要写的代码还要多，根据它写出C代码即可。

中断描述符表一个表项为8字节，把它看成一个64位整数。中断服务程序入口点的（代码）段选择子在31-16位。由于历史原因，中断服务程序入口点的段偏移量被拆散到两个不连续的地方：偏移量的15-0位在15-0位，31-16位在63-48位。

注意到`trap.h`中定义了`T_SYSCALL`以及`T_SWITCH_TOK`，它们是由用户态调用的软中断号，所以dpl应设置为3。

此外，我查阅了某文献得知`T_SYSCALL`还应设置`istrap`为1，否则在执行系统调用时无法及时响应中断，可能是个问题。

经过与参考答案对比：

1. 对于循环次数，我硬编码为256，参考答案的做法可以编译时计算，更优雅
2. 我直接使用内联汇编`lidt`，而答案使用封装好的`lidt`内联函数
3. 参考答案没有考虑`T_SYSCALL`

## 扩展练习1

### 内核态到用户态

这个子任务实现的重点在于给`iret`指令提供ss和esp。首先是存放地点的选择，我的实现没有对产生中断之前栈的情况做过多假设，所以不能用之前的栈空间，即不能直接修改tf指向的内容的ss和esp，因为此中断是在内核态的时候产生，处理器没有压入ss和esp（实际上，此时tf的ss和esp的位置分别对应`lab1_switch_to_user`的返回地址以及旧ebp）。我的办法是在当前栈上开设一个新的`trapframe`结构体（利用C语言局部变量即可），将旧的内容复制进去，然后进行如下设置。

需要设置各个段寄存器：cs设置为用户代码选择子，其他数据段寄存器设置为用户数据选择子。

需要注意的是esp的设置，esp需要设置为中断返回之后，`lab1_switch_to_user`函数能够正常返回。

为了用户能够使用`cprintf`进行输出，需要设置IOPL为用户态，修改tf的eflags就能够在中断返回的时候设置IOPL。

最后使用新的`trapframe`结构体进行中断返回。

### 用户态到内核态

由于中断在用户态触发时处理器会将栈切换到内核的另外一个栈，处理代码可以直接对原来的用户栈进行修改。在原来的用户栈上开设一个新的`trapframe`结构体，将旧的内容复制进去，然后进行和上面类似的设置。

注意不需要复制或设置ss和esp。同时，由于我的实现在中断返回之后不需要额外操作，不能为ss和esp预留空间，否则中断返回之后还需要恢复栈（手动弹出ss和esp）。

最后使用新的`trapframe`结构体进行中断返回。

经过与参考答案对比，我的实现没有对产生中断之前栈的情况做过多假设，在中断返回之后也不需要额外操作，所以`lab1_switch_to_user`以及`lab1_switch_to_kernel`的实现都只需要内联一条软中断指令`int`。这对扩展练习2的实现也有很大帮助。

## 扩展练习2

键盘中断是异步中断，由于我在实现扩展练习1时没有对产生中断之前栈的情况做过多假设，在中断返回之后也不需要额外操作，所以对于这个扩展练习，只需要在键盘中断处理程序中检测到0或3被按下时跳转到扩展练习1相应代码处执行即可。
