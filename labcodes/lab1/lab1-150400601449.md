# Lab1 report

## 练习1: 理解通过make生成执行文件的过程

### 练习1.1 
操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含
义， 以及说明命令导致的结果)

生成的操作系统镜像文件是 bin/ucore.img

创建ucore.img的代码：
```
# create ucore.img
UCOREIMG	:= $(call totarget,ucore.img)

$(UCOREIMG): $(kernel) $(bootblock)
	$(V)dd if=/dev/zero of=$@ count=10000
	$(V)dd if=$(bootblock) of=$@ conv=notrunc
	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc

$(call create_target,ucore.img)
```
其中
```
$(V)dd if=/dev/zero of=$@ count=10000
```
表示生成有10000个块的文件
```
$(V)dd if=$(bootblock) of=$@ conv=notrunc
```
表示开始写入bootblock
```
$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
```
表示开始写入kernel

以上代码的依赖项有kernel和bootblock

创建kernel target的代码：
```
# create kernel target
kernel = $(call totarget,kernel)

$(kernel): tools/kernel.ld

$(kernel): $(KOBJS)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)

$(call create_target,kernel)
```

创建bootblock的代码：
```
# create bootblock
bootfiles = $(call listf_cc,boot)
$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))

bootblock = $(call totarget,bootblock)

$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)

$(call create_target,bootblock)
```

### 练习1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

/tools/sign.c  用于生成一个符合规范的硬盘主引导扇区

创建主引导扇区(boot sector)的代码如下：
```
char buf[512];
memset(buf, 0, sizeof(buf));
FILE *ifp = fopen(argv[1], "rb");
int size = fread(buf, 1, st.st_size, ifp);
if (size != st.st_size) {
    fprintf(stderr, "read '%s' error, size is %d.\n", argv[1], size);
    return -1;
}
fclose(ifp);
buf[510] = 0x55;
buf[511] = 0xAA;
FILE *ofp = fopen(argv[2], "wb+");
size = fwrite(buf, 1, 512, ofp);
if (size != 512) {
    fprintf(stderr, "write '%s' error, size is %d.\n", argv[2], size);
    return -1;
}
fclose(ofp);
```
可以看出，buf是主引导扇区，其大小为512字节，第511字节的值是0x55， 第512字节的值是0xAA

## 练习2:使用qemu执行并调试lab1中的软件
### 练习2.1 从CPU加电后执行的第一条指令开始， 单步跟踪BIOS的执行
步骤：
1.在lab1目录下，执行：
```
make debug
```
2.在gdb中，输入：
```
step
```
单步跟踪执行

3.在gdb中，输入:
```
define hook-stop
x/i $pc
end
```
再进行单步调试，会显示出当前指令的反汇编代码

### 练习2.2 在初始化位置0x7c00设置实地址断点,测试断点正常
由bootasm.S中的注释可知，BIOS的初始化地址为0x7c00
tools/gdninit文件代码如下：
```
set architecture i8086
break *0x7c00
continue
x /2i $pc
```
在以上代码中，break设置断点地址

### 练习2.3 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
在Makefile中调用qemu的参数中增加-d in_asm -D $(BINDIR)/q.log，便可将运行的汇编指令保存到q.log中，所得代码如下：
```
----------------
IN:
0x00007c00:  cli    

----------------
IN:
0x00007c01:  cld    
0x00007c02:  xor    %ax,%ax
0x00007c04:  mov    %ax,%ds
0x00007c06:  mov    %ax,%es
0x00007c08:  mov    %ax,%ss

----------------
IN:
0x00007c0a:  in     $0x64,%al

----------------
IN:
0x00007c0c:  test   $0x2,%al
0x00007c0e:  jne    0x7c0a

----------------
IN:
0x00007c10:  mov    $0xd1,%al
0x00007c12:  out    %al,$0x64
0x00007c14:  in     $0x64,%al
0x00007c16:  test   $0x2,%al
0x00007c18:  jne    0x7c14

----------------
IN:
0x00007c1a:  mov    $0xdf,%al
0x00007c1c:  out    %al,$0x60
0x00007c1e:  lgdtw  0x7c6c
0x00007c23:  mov    %cr0,%eax
0x00007c26:  or     $0x1,%eax
0x00007c2a:  mov    %eax,%cr0

----------------
IN:
0x00007c2d:  ljmp   $0x8,$0x7c32

----------------
IN:
0x00007c32:  mov    $0x10,%ax
0x00007c36:  mov    %eax,%ds

----------------
IN:
0x00007c38:  mov    %eax,%es

----------------
IN:
0x00007c3a:  mov    %eax,%fs
0x00007c3c:  mov    %eax,%gs
0x00007c3e:  mov    %eax,%ss

----------------
IN:
0x00007c40:  mov    $0x0,%ebp

----------------
IN:
0x00007c45:  mov    $0x7c00,%esp
0x00007c4a:  call   0x7d0d

----------------
IN:
0x00007d0d:  push   %ebp
```
发现与bootasm.S和bootblock.asm中的代码相同

### 练习2.4 自己找一个bootloader或内核中的代码位置， 设置断点并进行测试
以课堂上的演示为例
tools/gdbinit代码如下：
```
file obj/bootblock.o
target remote :1234
break bootmain
continue
```
运行
```
make debug
```
即可运行到bootmain函数入口处

## 练习3：分析bootloader进入保护模式的过程。
bootasm.S完成了启动CPU，切换到32位保护模式，之后跳转到C代码。

启动地址是0:7c00，在实模式下，这也是运行bootloader的地址。

以下代码完成了16位实模式下的汇编，禁用中断
```
.globl start
start:
.code16                                             # Assemble for 16-bit mode
    cli                                             # Disable interrupts
    cld                                             # String operations increment
```
以下代码完成了数据段寄存器的设置
```
xorw %ax, %ax                                   # Segment number zero
movw %ax, %ds                                   # -> Data Segment
movw %ax, %es                                   # -> Extra Segment
movw %ax, %ss                                   # -> Stack Segment
```
以下代码启用了A20 Gate
```
seta20.1:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.1

    movb $0xd1, %al                                 # 0xd1 -> port 0x64
    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port

seta20.2:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.2

    movb $0xdf, %al                                 # 0xdf -> port 0x60
    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
```

以下代码完成了从实模式切换到保护模式，其中使用了全局描述符表(GDT)，使用段机制完成了从虚拟地址到物理地址的转换。
```
lgdt gdtdesc
movl %cr0, %eax
orl $CR0_PE_ON, %eax
movl %eax, %cr0
```

## 练习4：分析bootloader加载ELF格式的OS的过程。
### 练习4.1 bootloader如何读取硬盘扇区的？
```
/* readsect - read a single sector at @secno into @dst */
static void
readsect(void *dst, uint32_t secno) {
    // wait for disk to be ready
    waitdisk();

    outb(0x1F2, 1);                         // count = 1
    outb(0x1F3, secno & 0xFF);
    outb(0x1F4, (secno >> 8) & 0xFF);
    outb(0x1F5, (secno >> 16) & 0xFF);
    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors

    // wait for disk to be ready
    waitdisk();

    // read a sector
    insl(0x1F0, dst, SECTSIZE / 4);
}
```
readsect函数将一个扇区读入到dst指向的位置
```
static void
readseg(uintptr_t va, uint32_t count, uint32_t offset) {
    uintptr_t end_va = va + count;

    // round down to sector boundary
    va -= offset % SECTSIZE;

    // translate from bytes to sectors; kernel starts at sector 1
    uint32_t secno = (offset / SECTSIZE) + 1;

    // If this is too slow, we could read lots of sectors at a time.
    // We'd write more to memory than asked, but it doesn't matter --
    // we load in increasing order.
    for (; va < end_va; va += SECTSIZE, secno ++) {
        readsect((void *)va, secno);
    }
}
```
readseg函数将count字节数读入va指向的虚拟地址。

### 练习4.2 bootloader是如何加载ELF格式的OS？
```
/* bootmain - the entry of bootloader */
void
bootmain(void) {
    // read the 1st page off disk
    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);

    // is this a valid ELF?
    if (ELFHDR->e_magic != ELF_MAGIC) {
        goto bad;
    }

    struct proghdr *ph, *eph;

    // load each program segment (ignores ph flags)
    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
    eph = ph + ELFHDR->e_phnum;
    for (; ph < eph; ph ++) {
        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
    }

    // call the entry point from the ELF header
    // note: does not return
    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();

bad:
    outw(0x8A00, 0x8A00);
    outw(0x8A00, 0x8E00);

    /* do nothing */
    while (1);
}
```
bootmain函数是bootloader的入口。
bootmain首先调用readseg函数从磁盘读出第一页ELFHDR，也就是ELF的头部，然后通过检查幻数判断该ELF是否合法，然后读取程序段，从ELF头部找到内核的入口。

## 练习5
代码见lab1/kern/debug/kdebug.c

```
uint32_t *args = (uint32_t *)ebp + 2;
```
从当前ebp地址向上8bytes得到函数参数指针。

```
eip = ((uint32_t *)ebp)[1];
ebp = ((uint32_t *)ebp)[0];
```
eip得到函数返回地址。
ebp得到上一层的ebp值。

执行make qemu后，输出如下：
```
Special kernel symbols:
  entry  0x00100000 (phys)
  etext  0x001032c3 (phys)
  edata  0x0010ea16 (phys)
  end    0x0010fd20 (phys)
Kernel executable memory footprint: 64KB
ebp:0x00007b08 eip:0x001009a6 args:0x00010094 0x00000000 0x00007b38 0x00100092
    kern/debug/kdebug.c:306: print_stackframe+21
ebp:0x00007b18 eip:0x00100c95 args:0x00000000 0x00000000 0x00000000 0x00007b88
    kern/debug/kmonitor.c:125: mon_backtrace+10
ebp:0x00007b38 eip:0x00100092 args:0x00000000 0x00007b60 0xffff0000 0x00007b64
    kern/init/init.c:48: grade_backtrace2+33
ebp:0x00007b58 eip:0x001000bb args:0x00000000 0xffff0000 0x00007b84 0x00000029
    kern/init/init.c:53: grade_backtrace1+38
ebp:0x00007b78 eip:0x001000d9 args:0x00000000 0x00100000 0xffff0000 0x0000001d
    kern/init/init.c:58: grade_backtrace0+23
ebp:0x00007b98 eip:0x001000fe args:0x001032fc 0x001032e0 0x0000130a 0x00000000
    kern/init/init.c:63: grade_backtrace+34
ebp:0x00007bc8 eip:0x00100055 args:0x00000000 0x00000000 0x00000000 0x00010094
    kern/init/init.c:28: kern_init+84
ebp:0x00007bf8 eip:0x00007d68 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
    <unknow>: -- 0x00007d67 --
++ setup timer interrupts
(THU.CST) os is loading ...
```

输出信息从上到下，从低位地址到高位地址，从栈顶到栈底。

其中最后一行
```
ebp:0x00007bf8 eip:0x00007d68 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
```
是栈底的函数，即第一个函数，是bootmain函数。

## 练习6：完善中断初始化和处理
### 6.1 中断描述符表（ 也可简称为保护模式下的中断向量表） 中一个表项占多少字节？其中哪几位代表中断处理代码的入口？
IDT中的一个表项占8bytes，其中2-3bytes是segment selector，0-1bytes和6-7bytes是offset，由二者计算出ISR的入口地址。


### 6.2 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。 在idt_init函数中， 依次对所有中断入口进行初始化。 使用mmu.h中的SETGATE宏， 填充idt数组内容。 每个中断的入口由tools/vectors.c生成， 使用trap.c中声明的vectors数组即可。
见/lab1/kern/trap/trap.c

### 3 请编程完善trap.c中的中断处理函数trap， 在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分， 使操作系统每遇到100次时钟中断后， 调用print_ticks子程序， 向屏幕上打印一行文字”100 ticks”。
见/lab1/kern/trap/trap.c

## 扩展练习 Challenge 1
### 扩展proj4,增加syscall功能， 即增加一用户态函数（ 可执行一特定系统调用：获得时钟计数值） ， 当内核初始完毕后， 可从内核态返回到用户态的函数， 而用户态的函数又通过系统调用得到内核态的服务

见/lab1/kern/trap/trap.c

```
SETGATE(idt[T_SWITCH_TOK], 1, KERNEL_CS, __vectors[T_SWITCH_TOK], 3);
```
设置系统调用门（陷门）描述符，KERNEL_CS是段选择子，__vectors[T_SWITCH_TOK]是段内偏移，3表示用户特权级ring3，从而将T_SWITCH_TOK权限打开。

```
switchk2u = *tf;
switchk2u.tf_cs = USER_CS;
switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8;
switchk2u.tf_eflags |= FL_IOPL_MASK;
*((uint32_t *)tf - 1) = (uint32_t)&switchk2u;
```
设置用户态的栈帧。

```
tf->tf_cs = KERNEL_CS;
tf->tf_ds = tf->tf_es = KERNEL_DS;
tf->tf_eflags &= ~FL_IOPL_MASK;
switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe) - 8));
memmove(switchu2k, tf, sizeof(struct trapframe) - 8);
*((uint32_t *)tf - 1) = (uint32_t)switchu2k;
```
设置内核态的栈帧。
