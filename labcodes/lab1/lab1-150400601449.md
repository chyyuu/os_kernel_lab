# Lab1 report

## 练习1: 理解通过make生成执行文件的过程

### 练习1.1 
操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含
义， 以及说明命令导致的结果)

生成的操作系统镜像文件是 bin/ucore.img

创建ucore.img的代码：
```
# create ucore.img
UCOREIMG	:= $(call totarget,ucore.img)

$(UCOREIMG): $(kernel) $(bootblock)
	$(V)dd if=/dev/zero of=$@ count=10000
	$(V)dd if=$(bootblock) of=$@ conv=notrunc
	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc

$(call create_target,ucore.img)
```
其中
```
$(V)dd if=/dev/zero of=$@ count=10000
```
表示生成有10000个块的文件
```
$(V)dd if=$(bootblock) of=$@ conv=notrunc
```
表示开始写入bootblock
```
$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
```
表示开始写入kernel

以上代码的依赖项有kernel和bootblock

创建kernel target的代码：
```
# create kernel target
kernel = $(call totarget,kernel)

$(kernel): tools/kernel.ld

$(kernel): $(KOBJS)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)

$(call create_target,kernel)
```

创建bootblock的代码：
```
# create bootblock
bootfiles = $(call listf_cc,boot)
$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))

bootblock = $(call totarget,bootblock)

$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
	@echo + ld $@
	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)

$(call create_target,bootblock)
```

### 练习1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

/tools/sign.c  用于生成一个符合规范的硬盘主引导扇区

创建主引导扇区(boot sector)的代码如下：
```
char buf[512];
memset(buf, 0, sizeof(buf));
FILE *ifp = fopen(argv[1], "rb");
int size = fread(buf, 1, st.st_size, ifp);
if (size != st.st_size) {
    fprintf(stderr, "read '%s' error, size is %d.\n", argv[1], size);
    return -1;
}
fclose(ifp);
buf[510] = 0x55;
buf[511] = 0xAA;
FILE *ofp = fopen(argv[2], "wb+");
size = fwrite(buf, 1, 512, ofp);
if (size != 512) {
    fprintf(stderr, "write '%s' error, size is %d.\n", argv[2], size);
    return -1;
}
fclose(ofp);
```
可以看出，buf是主引导扇区，其大小为512字节，第511字节的值是0x55， 第512字节的值是0xAA

## 练习2:使用qemu执行并调试lab1中的软件
### 练习2.1 从CPU加电后执行的第一条指令开始， 单步跟踪BIOS的执行
步骤：
1.在lab1目录下，执行：
```
make debug
```
2.在gdb中，输入：
```
step
```
单步跟踪执行

3.在gdb中，输入:
```
define hook-stop
x/i $pc
end
```
再进行单步调试，会显示出当前指令的反汇编代码

### 练习2.2 在初始化位置0x7c00设置实地址断点,测试断点正常
由bootasm.S中的注释可知，BIOS的初始化地址为0x7c00
tools/gdninit文件代码如下：
```
set architecture i8086
break *0x7c00
continue
x /2i $pc
```
在以上代码中，break设置断点地址

### 练习2.3 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
在Makefile中调用qemu的参数中增加-d in_asm -D $(BINDIR)/q.log，便可将运行的汇编指令保存到q.log中，所得代码如下：
```
----------------
IN:
0x00007c00:  cli    

----------------
IN:
0x00007c01:  cld    
0x00007c02:  xor    %ax,%ax
0x00007c04:  mov    %ax,%ds
0x00007c06:  mov    %ax,%es
0x00007c08:  mov    %ax,%ss

----------------
IN:
0x00007c0a:  in     $0x64,%al

----------------
IN:
0x00007c0c:  test   $0x2,%al
0x00007c0e:  jne    0x7c0a

----------------
IN:
0x00007c10:  mov    $0xd1,%al
0x00007c12:  out    %al,$0x64
0x00007c14:  in     $0x64,%al
0x00007c16:  test   $0x2,%al
0x00007c18:  jne    0x7c14

----------------
IN:
0x00007c1a:  mov    $0xdf,%al
0x00007c1c:  out    %al,$0x60
0x00007c1e:  lgdtw  0x7c6c
0x00007c23:  mov    %cr0,%eax
0x00007c26:  or     $0x1,%eax
0x00007c2a:  mov    %eax,%cr0

----------------
IN:
0x00007c2d:  ljmp   $0x8,$0x7c32

----------------
IN:
0x00007c32:  mov    $0x10,%ax
0x00007c36:  mov    %eax,%ds

----------------
IN:
0x00007c38:  mov    %eax,%es

----------------
IN:
0x00007c3a:  mov    %eax,%fs
0x00007c3c:  mov    %eax,%gs
0x00007c3e:  mov    %eax,%ss

----------------
IN:
0x00007c40:  mov    $0x0,%ebp

----------------
IN:
0x00007c45:  mov    $0x7c00,%esp
0x00007c4a:  call   0x7d0d

----------------
IN:
0x00007d0d:  push   %ebp
```
发现与bootasm.S和bootblock.asm中的代码相同

### 练习2.4 自己找一个bootloader或内核中的代码位置， 设置断点并进行测试
以课堂上的演示为例
tools/gdbinit代码如下：
```
file obj/bootblock.o
target remote :1234
break bootmain
continue
```
运行
```
make debug
```
即可运行到bootmain函数入口处
