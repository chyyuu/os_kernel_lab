challenge1:实现识别dirty bit的 extended clock页替换算法
===================================================
状态：完成
lab3x-extend-clock-readme.md为报告，里面简要描述了设计思路，解释了测试用例。主要增加了extend_clock_swap.c这个类，并修改了swap.c等原有的程序。
https://github.com/chyyuu/ucore_lab/tree/lab3_X/labcodes_answer/lab3_result

完成人：
黄杰 2012011272   huangjie_cpp@163.com
袁源 2012011294   thuyuany12@163.com
杜鹃 2012011354   duj09225@gmail.com


challenge2:实现工作集页替换算法
===================================================
提示：

对于 工作集置换算法和缺页率置换算法，一个难点是如何精确记录页访问的时间先后顺序。我理解这是做不到的。

对于工作集置换算法，我的大致思路如下：工作集页面置换算法是全局页面置换算法。
有了工作集的定义并不意味着存在一种有效的方法能够在程序运行期间及时地计算出工作集。
作为替代，一种近似方法是基于执行时间片段统计工作集。
例如，按照以前的方法，我们定义工作集为前100万次内存访问所使用过的页面集合，
那么现在就可以这样定义：工作集即是过去100ms中的内存访问所用到的页面集合。
实际上，这样的模型很合适且更容易实现。每个进程只计算它自己的执行时间。

这里假定CPU会在访问某页后，会置对应的页表项的Dirty位和Access位。时钟中断10ms产生一次。

如果一个进程在T时刻开始，在（T+100）ms的时刻使用了40ms CPU时间，
对工作集而言，它的时间就是40ms，有大约4次中断。
一个进程从它开始执行到当前所实际使用的CPU时间总数通常称作当前实际运行时间。
通过这个近似的方法，进程的工作集可以被称为在过去的40ms（t值）实际运行时间中它所访问过的页面的集合。

问题0：何时统计页是否在工作集？
一定数量的时钟中断产生后，会进行统计。即会基于当前进程/线程的页表项，对页表项进行统计，
如果发现某些页表项的access bit设置为1，则在全局的物理页管理的数据结构（Page 结构需要扩展一下）中记录其访问时间（近似值）。
并吧access bit清零。这样就可以形成一个全局的物理页的工作集。

问题1：何时开始进行工作集替换算法？
（当系统内存小于一定下限 lower bound）后，有一个内核线程会被激活，
开始进行工作集置换算法，查找的是Page 结构的全局页表。我觉得这样比随时把页换出去效率更高一些。

状态：未完成　有小组在做
完成人：

challenge3:实现缺页率页替换算法
===================================================
状态：未完成
完成人：

challenge4:实现LIRS页替换算法
===================================================
状态：未完成
完成人：
